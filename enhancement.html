<!DOCTYPE html>
<html lang="ko" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>ì•„ì´í…œ ê°•í™” ì‹œë®¬ë ˆì´í„°</title>
  <style>
    :root {
      --bg-color: #f4f4f4;
      --text-color: #000000;
      --container-bg: #ffffff;
      --border-color: #dddddd;
      --control-bg: #eeeeee;
      --control-hover: #dddddd;
      --shadow: rgba(0,0,0,0.1);
      --safe-color: #d0ffd0;
      --break-color: #ffd0d0;
      --target-color: #fff2aa;
    }
    html.dark {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --container-bg: #1e1e1e;
      --border-color: #333333;
      --control-bg: #2c2c2c;
      --control-hover: #3a3a3a;
      --shadow: rgba(0,0,0,0.5);
      --safe-color: #295929;
      --break-color: #592929;
      --target-color: #665c1a;
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 16px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background-color .3s, color .3s;
      touch-action: manipulation;
    }
    .theme-toggle { position: absolute; top: 10px; right: 10px; }
    .theme-btn { background: none; border: none; font-size: 1.5rem; filter: grayscale(100%); cursor: pointer; transition: filter .3s; color: var(--text-color); }
    footer { text-align:center; font-size:0.8rem; color: var(--text-color); margin-top:8px; }
    .theme-btn:hover { filter: grayscale(0%); }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 4px; margin-bottom: 8px; }
    #reg-controls {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
    }
    #reg-controls button { width: 100%; }
    .reset-row { grid-column: 1 / -1; display: flex; justify-content: center; gap: 4px; }
    .controls button { padding: 8px; background: var(--control-bg); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; color: var(--text-color); font-size: 0.8rem; transition: background .3s; }
    .controls button:hover { background: var(--control-hover); }
    #resetBtn, #maxBtn { padding: 12px 8px; }
    #enhance-bar { display: flex; gap: 4px; margin-bottom: 8px; }
    .step { flex: 1; padding: 4px; text-align: center; border: 1px solid var(--border-color); background: var(--control-bg); cursor: pointer; }
    .step.selected { outline: 2px solid var(--target-color); }
    .step.safe { background: var(--safe-color); }
    .step.break { background: var(--break-color); }
    #entry-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 4px; margin-bottom: 8px; justify-items: center; }
    .slot { position: relative; width: 100%; max-width: 70px; aspect-ratio: 1 / 1; border: 1px solid var(--border-color); background: var(--container-bg); display: flex; align-items: center; justify-content: center; overflow: visible; }
    .card {
      position: relative;
      font-weight: bold;
      font-size: 0.7rem;
      text-align: center;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .card.selected::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 6px;
      border: 2px solid var(--target-color);
      box-shadow: 0 0 6px var(--target-color);
      background: conic-gradient(#fff, var(--target-color) 30deg, var(--target-color) 60deg, #fff 100deg);
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
              mask-composite: exclude;
      animation: rotateHighlight 8s linear infinite;
      pointer-events: none;
    }
    @keyframes rotateHighlight {
      to { transform: rotate(1turn); }
    }
    .card .img {
      width: 90%;
      height: 90%;
      margin: auto;
      object-fit: contain;
      flex: 1;
    }
    .card .name { display:none; font-size: 0.7rem; }
    .card.selected .name { display:block; }
    .card .level {
      position:absolute;
      bottom:2px;
      right:2px;
      font-size: 0.8rem;
    }
    .card.type-ë¬´ê¸° .img { content:url('img/weapon.gif'); }
    .card.type-ë°©ì–´êµ¬ .img { content:url('img/armor.gif'); }
    .card.type-ê·¸ë¡œì•„-ì¥ë¹„ .img { content:url('img/groa.gif'); }
    .card.type-ì¥ì‹ êµ¬ .img { content:url('img/accessory.gif'); }
    .card.type-ì»¬ë ‰ì…˜-ì „ìš©-ì•„ì´í…œ .img { content:url('img/collection.gif'); }
    .card.type-í˜ë¥´ë””íƒ€ .img { content:url('img/perdita.gif'); }
    .card.type-ìœ ë¬¼ .img { content:url('img/relic.gif'); }
    .shatter-overlay {
      position:absolute;
      inset:0;
      background:url('img/shatter.gif') center/cover no-repeat;
      pointer-events:none;
      animation: shatterFade 0.6s forwards;
    }
    @keyframes shatterFade { to { opacity:0; transform:scale(1.2); } }
    .success { animation: successFlash 0.6s; }
    .fail { animation: failFlash 0.6s; }
    .maintain { animation: maintainFlash 0.6s; }
    .guide { margin: 4px 0; font-size: 0.9rem; color: var(--text-color); }
    .run-controls { display: flex; gap: 4px; justify-content: center; margin-bottom: 8px; }
    .run-controls button { flex:1; padding: 8px; background: var(--control-bg); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; color: var(--text-color); font-size: 1rem; transition: background .3s; }
    .run-controls button:hover { background: var(--control-hover); }
    .select-controls { display: flex; gap: 4px; justify-content: center; margin-bottom: 8px; }
    .select-controls button { flex:1; padding: 8px; background: var(--control-bg); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; color: var(--text-color); font-size: 1rem; transition: background .3s; }
    .select-controls button:hover { background: var(--control-hover); }
    @keyframes successFlash {
      0% { background: var(--safe-color); transform: scale(1); box-shadow: 0 0 0 0 var(--safe-color); }
      50% { background: var(--safe-color); transform: scale(1.05); box-shadow: 0 0 8px 4px var(--safe-color); }
      100% { background: inherit; transform: scale(1); box-shadow: none; }
    }
    @keyframes failFlash {
      0% { background: var(--break-color); transform: scale(1); box-shadow: 0 0 0 0 var(--break-color); }
      50% { background: var(--break-color); transform: scale(0.95); box-shadow: 0 0 8px 4px var(--break-color); }
      100% { background: inherit; transform: scale(1); box-shadow: none; }
    }
    @keyframes maintainFlash {
      0% { background: var(--target-color); transform: scale(1); box-shadow: 0 0 0 0 var(--target-color); }
      50% { background: var(--target-color); transform: scale(1.02); box-shadow: 0 0 6px 3px var(--target-color); }
      100% { background: inherit; transform: scale(1); box-shadow: none; }
    }
  </style>
</head>
<body>
  <div class="theme-toggle"><button id="toggleTheme" class="theme-btn">ğŸŒ™</button></div>
  <h1>ì•„ì´í…œ ê°•í™” ì‹œë®¬ë ˆì´í„°</h1>
  <div class="controls">
    <div id="reg-controls"></div>
    <div class="reset-row">
      <button id="resetBtn">ì´ˆê¸°í™”</button>
      <button id="maxBtn">MAX</button>
    </div>
  </div>
  <div id="enhance-bar"></div>
  <div id="entry-grid"></div>
  <p class="guide">ëª©í‘œ ë‹¨ê³„(ê°•í™” ë°”)ë¥¼ ì„ íƒ í›„ ì‹¤í–‰í•˜ì„¸ìš”</p>
  <div class="run-controls">
    <button onclick="decreaseAll()">-1</button>
    <button onclick="enhanceOnce()">+1</button>
    <button id="harkiniBtn" onclick="enhanceHarkiniOnce()" disabled>í•˜ë¥´í‚¤ë‹ˆ</button>
    <button id="kaleilBtn" onclick="enhanceKaleilOnce()" disabled>ì¹¼ë ˆì¼</button>
    <button onclick="enhanceOnce(true)">ì¶•ë³µ</button>
    <button onclick="enhanceAllSteps()">ë‹¤ì¤‘ê°•í™”</button>
  </div>
  <div class="select-controls">
    <button onclick="selectSameLevel()">ë™ì¼ë“±ê¸‰ì„ íƒ</button>
    <button onclick="deselectAll()">ì„ íƒí•´ì œ</button>
  </div>
  <div id="usage-summary" class="guide"></div>
  <div id="entry-summary" class="guide"></div>

  <script src="enhance_rates.js" defer></script>
  <script>
    const entries = [];
    const typeImages = {
      'ë¬´ê¸°': 'img/weapon.gif',
      'ë°©ì–´êµ¬': 'img/armor.gif',
      'ê·¸ë¡œì•„ ì¥ë¹„': 'img/groa.gif',
      'ì¥ì‹ êµ¬': 'img/accessory.gif',
      'ì»¬ë ‰ì…˜ ì „ìš© ì•„ì´í…œ': 'img/collection.gif',
      'í˜ë¥´ë””íƒ€': 'img/perdita.gif',
      'ìœ ë¬¼': 'img/relic.gif'
    };
    let entryGrid;
    let selectedTarget = 1;
    let lastSelectedId = null;
    let usage = { normal: 0, bless: 0, harkini: 0, kaleil: 0 };
    let consumed = 0;
    let currentType = null;

    function renderSummary() {
      const el = document.getElementById('usage-summary');
      if (el) {
        el.textContent = `ê¸°ë³¸:${usage.normal} í•˜ë¥´í‚¤ë‹ˆ:${usage.harkini} ì¹¼ë ˆì¼:${usage.kaleil} ì¶•ë³µ:${usage.bless}`;
      }
      const entryEl = document.getElementById('entry-summary');
      if (entryEl) {
        entryEl.textContent = `ê°•í™”ì‹¤íŒ¨:${consumed}`;
      }
    }

    function initialLevelFor(type) {
      return (type === 'í˜ë¥´ë””íƒ€' || type === 'ìœ ë¬¼') ? 5 : 0;
    }

    function populateControls() {
      updateButtons();
    }

    function updateButtons() {
      const regControls = document.getElementById('reg-controls');
      regControls.innerHTML = '';
      const baseRates = window.enhanceRates['ê¸°ë³¸'];
      const types = Object.keys(baseRates).sort();
      types.forEach(type => {
        const levels = Object.keys(baseRates[type])
          .map(Number)
          .sort((a, b) => a - b);
        levels.forEach(safe => {
          const btn = document.createElement('button');
          btn.textContent = `${type} ${safe}ì•ˆì „`;
          btn.onclick = () => registerItem(type, safe);
          regControls.appendChild(btn);
        });
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      entryGrid = document.getElementById('entry-grid');
      for (let i = 0; i < 40; i++) {
        const slot = document.createElement('div');
        slot.className = 'slot';
        entryGrid.appendChild(slot);
      }
      populateControls();
      document.getElementById('resetBtn').onclick = resetAll;
      document.getElementById('maxBtn').onclick = fillMax;
      document.getElementById("enhance-bar").innerHTML =
        Array.from({ length: 20 }, (_, i) =>
          `<div class="step" onclick="setTargetLevel(${i + 1})">+${i + 1}</div>`
        ).join('');
      updateStepBar();
      document.getElementById('toggleTheme')
        .addEventListener('click', () =>
          document.documentElement.classList.toggle('dark'));
      updateHarkiniButton();
      updateKaleilButton();
      renderSummary();

    });

    // 2) ìƒë‹¨ ê°•í™”ë°” ìƒì„± & í´ë¦­ í•¸ë“¤ëŸ¬
    function setTargetLevel(n) {
      selectedTarget = n;
      updateStepBar();
    }
    function updateStepBar() {
      const item = entries[0];
      const safeLevel = item?.safeLevel || 0;
      const rateTable = item ? window.enhanceRates[item.scroll]?.[item.type]?.[item.safeLevel] : null;
      document.querySelectorAll('.step').forEach((el, i) => {
        const level = i + 1;
        const breakable = rateTable?.[String(level - 1)]?.break;
        el.classList.toggle('selected', level <= selectedTarget);
        el.classList.toggle('safe',     level <= safeLevel);
        el.classList.toggle('break',    !!breakable);
      });
      updateHarkiniButton();
      updateKaleilButton();
    }


    // 3) ì•„ì´í…œ ë“±ë¡/ë Œë”/ë¦¬ì…‹
    function registerItem(type, safeLevel) {
      const scroll = 'ê¸°ë³¸';
      if (entries.length && entries[0].type !== type) {
        alert('ë™ì¼í•œ ìœ í˜•ë§Œ ë“±ë¡ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
        return;
      }
      if (!entries.length && currentType && currentType !== type) {
        usage = { normal: 0, bless: 0, harkini: 0, kaleil: 0 };
        consumed = 0;
        renderSummary();
      }
      if (!entries.length) currentType = type;
      if (entries.length >= 40) return;
      entries.push({
        id: Date.now() + Math.random(),
        type,
        level: initialLevelFor(type),
        safeLevel,
        scroll,
        destroyed: false,
        selected: false
      });
      renderEntries();
      updateStepBar();
    }
    function typeClass(type) {
      return 'type-' + type.replace(/\s+/g, '-');
    }

    function levelColor(lv) {
      const hue = 120 - Math.min(lv, 20) * 6;
      return `hsl(${hue}, 80%, 60%)`;
    }

    function toggleSelect(id) {
      const item = entries.find(it => it.id === id);
      if (item) {
        item.selected = !item.selected;
        if (item.selected) {
          lastSelectedId = id;
        } else if (lastSelectedId === id) {
          lastSelectedId = null;
        }
      }
      renderEntries();
      updateStepBar();
    }

    function selectedEntries() {
      const sel = entries.filter(it => it.selected);
      return sel.length ? sel : entries;
    }

    function renderEntries() {
      entryGrid.querySelectorAll('.slot').forEach((slot, i) => {
        slot.innerHTML = '';
        const item = entries[i];
        if (item && !item.destroyed) {
          const card = document.createElement('div');
          card.className = 'card ' + typeClass(item.type) + (item.selected ? ' selected' : '');
          card.dataset.id = item.id;
          card.onclick = () => toggleSelect(item.id);

          const img = document.createElement('img');
          img.className = 'img';
          img.alt = item.type;
          img.src = typeImages[item.type] || '';
          card.appendChild(img);

          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = item.type;
          card.appendChild(name);

          const level = document.createElement('div');
          level.className = 'level';
          level.textContent = `+${item.level}`;
          level.style.color = levelColor(item.level);
          card.appendChild(level);

          slot.appendChild(card);
        }
      });
      updateHarkiniButton();
      updateKaleilButton();
    }
    function resetAll() {
      entries.length = 0;
      renderEntries();
      selectedTarget = 0;
      usage = { normal: 0, bless: 0, harkini: 0, kaleil: 0 };
      consumed = 0;
      currentType = null;
      renderSummary();
      updateStepBar();
    }

    function fillMax() {
      if (!entries.length) return;
      const { type, safeLevel, scroll } = entries[0];
      const baseLevel = initialLevelFor(type);
      while (entries.length < 40) {
        entries.push({
          id: Date.now() + Math.random(),
          type,
          level: baseLevel,
          safeLevel,
          scroll,
          destroyed: false,
          selected: false
        });
      }
      renderEntries();
      updateStepBar();
    }

    function decreaseAll() {
      selectedEntries().forEach(it => {
        if (it.level > 0) it.level--;
      });
      renderEntries();
      updateStepBar();
    }

    function deselectAll() {
      entries.forEach(it => it.selected = false);
      lastSelectedId = null;
      renderEntries();
      updateStepBar();
    }

    function selectSameLevel() {
      const base = entries.find(it => it.id === lastSelectedId && it.selected);
      if (!base) return;
      entries.forEach(it => {
        if (it.level === base.level) it.selected = true;
      });
      renderEntries();
      updateStepBar();
    }

    // 4) í™•ë¥ í‘œëŠ” enhance_rates.jsì—ì„œ ë¡œë“œ

      function getEnhanceResult(item, bless) {
        const rates = window.enhanceRates[item.scroll]?.[item.type]?.[item.safeLevel]?.[String(item.level)];
        if (!rates) return { success:false, destroyed:false, increment:0 };
        if (item.scroll === 'í•˜ë¥´í‚¤ë‹ˆ' && !bless) {
          let r = Math.random();
          if (r < rates.base) return { success:true, destroyed:false, increment:1 };
          r -= rates.base;
          if (r < (rates.break||0)) return { success:true, destroyed:false, increment:2 };
          r -= (rates.break||0);
          if (r < (rates.drop||0)) return { success:false, destroyed:false, increment:-1 };
          return { success:false, destroyed:false, increment:0 };
        }
        if (bless) {
          const r = Math.random();
          let sum = 0;
          for (let i = 0; i < rates.bless.length; i++) {
            sum += rates.bless[i];
            if (r < sum) {
              return { success:true, destroyed:false, increment:i + 1 };
            }
          }
          return { success:false, destroyed:Math.random() < (rates.break||0), increment:0 };
        }
        let r = Math.random();
        if (r < rates.base) {
          const plusRates = rates.plus || [1];
          let r2 = Math.random();
          let sum = 0;
          for (let i = 0; i < plusRates.length; i++) {
            sum += plusRates[i];
            if (r2 < sum) {
              return { success:true, destroyed:false, increment:i + 1 };
            }
          }
          return { success:true, destroyed:false, increment:1 };
        }
        r -= rates.base;
        if (r < (rates.break||0)) return { success:false, destroyed:true, increment:0 };
        r -= (rates.break||0);
        if (r < (rates.drop||0)) return { success:false, destroyed:false, increment:-1 };
        return { success:false, destroyed:false, increment:0 };
      }

    function waitForAnim(card, cls) {
      return new Promise(res => {
        card.classList.add(cls);
        card.addEventListener('animationend', () => {
          card.classList.remove(cls);
          res();
        }, { once:true });
      });
    }

    function shatterCard(card) {
      return new Promise(res => {
        const overlay = document.createElement('div');
        overlay.className = 'shatter-overlay';
        card.appendChild(overlay);
        overlay.addEventListener('animationend', () => {
          overlay.remove();
          card.remove();
          res();
        }, { once: true });
      });
    }

    function canUseHarkini() {
      const first = entries[0];
      return !!window.enhanceRates['í•˜ë¥´í‚¤ë‹ˆ']?.[first?.type]?.[first?.safeLevel]?.[String(first?.level)];
    }

    function canUseKaleil() {
      const first = entries[0];
      return !!window.enhanceRates['ì¹¼ë ˆì¼']?.[first?.type]?.[first?.safeLevel]?.[String(first?.level)];
    }

    function updateHarkiniButton() {
      const btn = document.getElementById('harkiniBtn');
      if (btn) btn.disabled = !canUseHarkini();
    }

    function updateKaleilButton() {
      const btn = document.getElementById('kaleilBtn');
      if (btn) btn.disabled = !canUseKaleil();
    }

    async function enhanceHarkiniOnce() {
      const targets = selectedEntries();
      renderEntries();

      const realTargets = targets.filter(it => !it.destroyed);
      usage.harkini += realTargets.length;
      renderSummary();

      const promises = targets.map(item => {
        if (item.destroyed) return Promise.resolve();
        const result = getEnhanceResult({ ...item, scroll: 'í•˜ë¥´í‚¤ë‹ˆ' });
        item.destroyed = result.destroyed;
        const card = document.querySelector(`.card[data-id="${item.id}"]`);
        if (result.success) {
          item.level += result.increment;
          return waitForAnim(card, 'success');
        } else if (result.destroyed) {
          return shatterCard(card);
        } else if (result.increment < 0) {
          item.level = Math.max(0, item.level + result.increment);
          return waitForAnim(card, 'fail');
        }
        return waitForAnim(card, 'maintain');
      });

      await Promise.all(promises);

      const before = entries.length;
      for (let i = entries.length - 1; i >= 0; i--) {
        if (entries[i].destroyed) entries.splice(i, 1);
      }
      consumed += before - entries.length;
      renderEntries();
      updateStepBar();
      renderSummary();
    }

    async function enhanceKaleilOnce() {
      const targets = selectedEntries();
      renderEntries();

      const realTargets = targets.filter(it => !it.destroyed);
      usage.kaleil += realTargets.length;
      renderSummary();

      const promises = targets.map(item => {
        if (item.destroyed) return Promise.resolve();
        const result = getEnhanceResult({ ...item, scroll: 'ì¹¼ë ˆì¼' });
        item.destroyed = result.destroyed;
        const card = document.querySelector(`.card[data-id="${item.id}"]`);
        if (result.success) {
          item.level += result.increment;
          return waitForAnim(card, 'success');
        } else if (result.destroyed) {
          return shatterCard(card);
        } else if (result.increment < 0) {
          item.level = Math.max(0, item.level + result.increment);
          return waitForAnim(card, 'fail');
        }
        return waitForAnim(card, 'maintain');
      });

      await Promise.all(promises);

      const before = entries.length;
      for (let i = entries.length - 1; i >= 0; i--) {
        if (entries[i].destroyed) entries.splice(i, 1);
      }
      consumed += before - entries.length;
      renderEntries();
      updateStepBar();
      renderSummary();
    }

    async function enhanceOnce(bless = false, useTarget = false) {
        const targets = selectedEntries();
        if (useTarget) {
          targets.forEach(it => {
            if (it.level < it.safeLevel && selectedTarget >= it.safeLevel) {
              it.level = it.safeLevel;
            }
          });
        }
        renderEntries();

      const realTargets = targets.filter(item => {
        if (item.destroyed) return false;
        if (useTarget) {
          if (item.level >= selectedTarget) return false;
          if (item.level < item.safeLevel && selectedTarget >= item.safeLevel) {
            return false;
          }
        }
        return true;
      });
      usage[bless ? 'bless' : 'normal'] += realTargets.length;
      renderSummary();

      const promises = targets.map(item => {
        if (item.destroyed) return Promise.resolve();
        if (useTarget) {
          if (item.level >= selectedTarget) return Promise.resolve();
          if (item.level < item.safeLevel && selectedTarget >= item.safeLevel) {
            return Promise.resolve();
          }
        }

        const result = getEnhanceResult(item, bless);
        item.destroyed = result.destroyed;
        const card = document.querySelector(`.card[data-id="${item.id}"]`);
        if (result.success) {
          item.level += result.increment;
          return waitForAnim(card, 'success');
        } else if (result.destroyed) {
          return shatterCard(card);
        } else if (result.increment < 0) {
          item.level = Math.max(0, item.level + result.increment);
          return waitForAnim(card, 'fail');
        }
        return waitForAnim(card, 'maintain');
      });

      await Promise.all(promises);

      const before = entries.length;
      for (let i = entries.length - 1; i >= 0; i--) {
        if (entries[i].destroyed) entries.splice(i, 1);
      }
      consumed += before - entries.length;
      renderEntries();
      updateStepBar();
      renderSummary();
    }

  async function enhanceAllSteps() {
    while (selectedEntries().some(it => !it.destroyed && it.level < selectedTarget)) {
      await enhanceOnce(false, true);
      await new Promise(r => requestAnimationFrame(r));
    }
  }

  </script>
  <footer><small>ë²„ì „ v1.3.17</small></footer>
</body>
</html>
